<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Counting reads &#8212; HTSeq 0.7.2 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Reference overview" href="refoverview.html" />
    <link rel="prev" title="A detailed use case: TSS plots" href="tss.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="refoverview.html" title="Reference overview"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tss.html" title="A detailed use case: TSS plots"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">HTSeq 0.7.2 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="counting-reads">
<span id="counting"></span><h1>Counting reads<a class="headerlink" href="#counting-reads" title="Permalink to this headline">¶</a></h1>
<p>A very typical use case for the HTSeq library is to for a given list of genomic features (such as genes,
exons, ChIP-Seq peaks, or the like), how many sequencing reads overlap each of the features. As a more
complex example for using HTSeq, we supply the script <code class="docutils literal"><span class="pre">htseq-count</span></code>, which takes a GTF file with
gene models and a SAM file and counts for each gene how many reads map to it; see Section <a class="reference internal" href="count.html#count"><span class="std std-ref">Counting reads in features with htseq-count</span></a>.</p>
<p>The <code class="docutils literal"><span class="pre">htseq-count</span></code> script, however, has implementation details which were chosen with a specific use
case in mind, namely to quantify gene expression for subsequent testing for differential expression,
which is why, for example, the script does not count reads that map to multiple genes. For other
applications, different resolutions of such ambiguities might be desirable, and then, a bioinformatician
may want to create her own counting script. In the following, we expand on the coverage of this
topic in the <em>Tour</em> (<a class="reference internal" href="tour.html#tour"><span class="std std-ref">A tour through HTSeq</span></a>) and give building blocks which should make it possible to write such scripts
also for bioinformaticians with only modest knowledge of Python.</p>
<div class="section" id="preparing-the-feature-array">
<h2>Preparing the feature array<a class="headerlink" href="#preparing-the-feature-array" title="Permalink to this headline">¶</a></h2>
<p>Our general approach is to define a <a class="reference internal" href="genomic.html#HTSeq.GenomicArrayOfSets" title="HTSeq.GenomicArrayOfSets"><code class="xref py py-class docutils literal"><span class="pre">GenomicArrayOfSets</span></code></a> and fill it with all the features we would
like to get counts for.</p>
<p>Similar to the code shown in the <em>Tour</em>, we prepare such an object from the GTF file for yeast as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">HTSeq</span>

<span class="n">gtf_file</span> <span class="o">=</span> <span class="n">HTSeq</span><span class="o">.</span><span class="n">GFF_Reader</span><span class="p">(</span> <span class="s2">&quot;Saccharomyces_cerevisiae.SGD1.01.56.gtf.gz&quot;</span> <span class="p">)</span>
<span class="n">exons</span> <span class="o">=</span> <span class="n">HTSeq</span><span class="o">.</span><span class="n">GenomicArrayOfSets</span><span class="p">(</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">stranded</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>

<span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">gtf_file</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;exon&quot;</span><span class="p">:</span>
       <span class="n">exons</span><span class="p">[</span> <span class="n">feature</span><span class="o">.</span><span class="n">iv</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">feature</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s2">&quot;gene_id&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>A few things might be noteworthy here: For each exon, we just store the gene ID in the genomic array. Hence,
all exons from the same gene are represented with the same string. This is deliberate, as we want to count
on the level of genes, not exons, but could be done differently: storing the whole <code class="docutils literal"><span class="pre">feature</span></code> object in
the GenomicArrayOfSets uses up noticeably more memory but allows to access more information in downstream
processing.</p>
<p>Also note that in a GTF file, an exon that appears in several transcripts appear once for each
transcripts. Because all these exons are represented by the same name, they will be collapsed to a single
value in the GenomicArrayOfSets.</p>
<p>GTF files are not the only source of feature annotations. One could, as well, read a BED file or other
text file with genomic coordinates of, say, ChIP-Seq peaks, putative enhancers, or any other kind of data.
For example, if we have a tab-separated text file with feature coordinates in four columns &#8211; feature ID,
chromosome, start, end &#8211; we might use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">features</span> <span class="o">=</span>  <span class="n">HTSeq</span><span class="o">.</span><span class="n">GenomicArrayOfSets</span><span class="p">(</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">stranded</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span> <span class="s2">&quot;myfeatures.txt&quot;</span> <span class="p">):</span>
   <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="p">)</span>
   <span class="n">iv</span> <span class="o">=</span> <span class="n">HTSeq</span><span class="o">.</span><span class="n">GenomicInterval</span><span class="p">(</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">)</span>
   <span class="n">features</span><span class="p">[</span> <span class="n">iv</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, we have assumed that the coordinates follow Python conventions: The first base of a chromosome is
numbered 0, not 1, and the end position is not included in the interval. Remember to subtract or add 1 as
necessary if this is not the case with your input data.</p>
</div>
<div class="section" id="counting-ungapped-single-end-reads">
<h2>Counting ungapped single-end reads<a class="headerlink" href="#counting-ungapped-single-end-reads" title="Permalink to this headline">¶</a></h2>
<p>We start with the easiest case, that of ungapped single-end reads. We first recapitulate points
already shown in the <em>Tour</em> and then add further refinements in the following.</p>
<p>If we have a SAM file with unmapped reads, we might use the following code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span> <span class="p">)</span>

<span class="n">almnt_file</span> <span class="o">=</span> <span class="n">HTSeq</span><span class="o">.</span><span class="n">SAM_Reader</span><span class="p">(</span> <span class="s2">&quot;my_alignments.sam&quot;</span> <span class="p">)</span>
<span class="k">for</span> <span class="n">almnt</span> <span class="ow">in</span> <span class="n">almnt_file</span><span class="p">:</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">almnt</span><span class="o">.</span><span class="n">aligned</span><span class="p">:</span>
      <span class="n">count</span><span class="p">[</span> <span class="s2">&quot;_unmapped&quot;</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">continue</span>
   <span class="n">gene_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
   <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">features</span><span class="p">[</span> <span class="n">almnt</span><span class="o">.</span><span class="n">iv</span> <span class="p">]</span><span class="o">.</span><span class="n">steps</span><span class="p">():</span>
      <span class="n">gene_ids</span> <span class="o">|=</span> <span class="n">val</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">gene_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">counts</span><span class="p">[</span> <span class="n">gene_id</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
   <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">counts</span><span class="p">[</span> <span class="s2">&quot;_no_feature&quot;</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">counts</span><span class="p">[</span> <span class="s2">&quot;_ambiguous&quot;</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">gene_id</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
   <span class="nb">print</span> <span class="n">gene_id</span><span class="p">,</span> <span class="n">counts</span><span class="p">[</span> <span class="n">gene_id</span> <span class="p">]</span>
</pre></div>
</div>
<p>For the benefit of readers with only limited Python knowledge, we go through this code chunk
step by step:</p>
<p>The variable <code class="docutils literal"><span class="pre">counts</span></code> contains a dictionary, which will associate gene IDs with read counts. We
use a variant of Python&#8217;s usual <code class="docutils literal"><span class="pre">dict</span></code> type, namely the <code class="docutils literal"><span class="pre">Counter</span></code> class from the <code class="docutils literal"><span class="pre">collections</span></code>
module in the standard library (from Python 2.7 onwards), which initialized any new key with
the value zero. (Users of Python 2.6 can use <code class="docutils literal"><span class="pre">collections.defaultdict(int)</span></code> instead.)</p>
<p>We then instantiate a <code class="xref py py-class docutils literal"><span class="pre">SAM_Reader`</span></code> object (If you have a BAM file, use <code class="docutils literal"><span class="pre">BAM_Reader</span></code>
instead) and run through all its record in a <code class="docutils literal"><span class="pre">for</span></code> loop. As described in the Tour, each record
in the SAM file is vprovided to the loop body in the variable <code class="docutils literal"><span class="pre">almnt</span></code>.</p>
<p>We first check whether the read might be unaligned, and if so, increment a special counter
that we call <code class="docutils literal"><span class="pre">_unmapped</span></code> (with an underscore as prefix to distinguish it from gene IDs).</p>
<p>For the aligned reads, the alignment&#8217;s genomic interval, <code class="docutils literal"><span class="pre">almnt.iv</span></code>, shows us the interval
covered by the read. Using this as an index to <code class="docutils literal"><span class="pre">feature</span></code> gives us a view on this
stretch of the <code class="docutils literal"><span class="pre">feature</span></code> container, in which we had stored the exons. The iterator
<code class="docutils literal"><span class="pre">features[</span> <span class="pre">almnt.iv</span> <span class="pre">].steps()</span></code> returns pairs of the form <code class="docutils literal"><span class="pre">(iv,</span> <span class="pre">val)</span></code>, where <code class="docutils literal"><span class="pre">iv</span></code> is
a genomic interval and <code class="docutils literal"><span class="pre">val</span></code> is the set of gene IDs associated with the exons overlapping
this step. Using the <code class="docutils literal"><span class="pre">|=</span></code> operator, we get the union of the sets of all the steps in the
initially empty set <code class="docutils literal"><span class="pre">gene_ids</span></code>, which, at the end, contains the gene IDs of all genes
that the read overlaps. Remember that a <code class="docutils literal"><span class="pre">set</span></code> can contain each element at most once. Hence,
even if we see the same gene in several steps (for example because the read overlaps with
several exons), we still get it only once in <code class="docutils literal"><span class="pre">gene_ids</span></code>.</p>
<p>We then treat three possible cases, namely that the set <code class="docutils literal"><span class="pre">gene_ids</span></code> contains exactly one element,
that it is empty, or that it contains mroe than one element. The first case is the desired one:
The read overlaps with precisely one gene, and we hence increase the count for this gene by one.
Note that we need the idiom <code class="docutils literal"><span class="pre">list(gene_ids)[0]</span></code> to extract the name of this single gene from
the set. If the read did not overlap with a gene (<code class="docutils literal"><span class="pre">len(gene_ids)</span> <span class="pre">==</span> <span class="pre">0</span></code>), we increase a special
counter that we call <code class="docutils literal"><span class="pre">_no_feature</span></code>.</p>
<p>What should we do if the read overlaps more than one gene? Here, one might now come up with
sophisticated logic to decide which gene to count the read for. To keep things simple, however,
we simply count the read for none of the overlapped genes and instead increase the
special counter <code class="docutils literal"><span class="pre">_ambiguous</span></code> .</p>
<p>In the final two lines, we loop through the counter to print out the counts.</p>
</div>
<div class="section" id="counting-gapped-single-end-reads">
<h2>Counting gapped single-end reads<a class="headerlink" href="#counting-gapped-single-end-reads" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cigar-operations">
<h3>CIGAR Operations<a class="headerlink" href="#cigar-operations" title="Permalink to this headline">¶</a></h3>
<p>The above code can be used as is e.g. for ChIP-Seq data, but for RNA-Seq data, we need an additional
ingredient: When sequencing RNA, many reads will pass over an exon-exon junction and hence align
to two (or more) disjunct intervals on the genome, tyically with an intron in between. If the reads
have been aligned with a splice-aware alignment tool, such gapped alignment is indicated in
the SAM file by the CIGAR string.</p>
<p>HTSeq parses the CIGAR string and presents it in the <code class="docutils literal"><span class="pre">cigar</span></code> slot of a class:<cite>SAM_Alignment</cite> object
as a list of class:<cite>CigarOperation</cite> objects. As an example, consider a SAM alignment record
describing a read that has been aligned to position 1000 on the &#8216;+&#8217;&#8217; strand of chromosome <code class="docutils literal"><span class="pre">chr1</span></code>,
with CIGAR string <code class="docutils literal"><span class="pre">20M300N30M2I8M</span></code>. Following the SAM specification (please read it first if
you are unfamiliar with CIGAR strings), this means an alignment as depicted here:</p>
<img alt="_images/cigar.png" src="_images/cigar.png" />
<p>[[TO DO: Nicer image, add &#8220;chr1:&#8221;]]</p>
<p>The <code class="docutils literal"><span class="pre">SAM_Alignment</span></code> object will hence have in its <code class="docutils literal"><span class="pre">cigar</span></code> slot a list of 5 objects, each giving the
information of one row of the table. Note how some operations are associated with zero-length intervals
on either the reference (i.e., chromosome) or the query (i.e., read). For example, the intron (<code class="docutils literal"><span class="pre">N200</span></code>)
spans 200 bp on the chromosome (1020-1320) but a zero-length interval on the read (20-20). In this manner,
the <code class="docutils literal"><span class="pre">CigarOperation</span></code> class conveniently shows which intervals are affected by which operation.</p>
</div>
<div class="section" id="counting-with-gapped-reads">
<h3>Counting with gapped reads<a class="headerlink" href="#counting-with-gapped-reads" title="Permalink to this headline">¶</a></h3>
<p>In the code above, we used this for loop</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gene_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">features</span><span class="p">[</span> <span class="n">almnt</span><span class="o">.</span><span class="n">iv</span> <span class="p">]</span><span class="o">.</span><span class="n">steps</span><span class="p">():</span>
    <span class="n">gene_ids</span> <span class="o">|=</span> <span class="n">val</span>
</pre></div>
</div>
<p>to collect the gene IDs of all exons overlapped by the reads interval. For loop runs over the whole
interval covered by the aligned read, i.e., in the figure above, it would run from position 1000
to position 1378 on chromosome 1, including the alignment gap from 1020 to 1320. By looking at each
cigar operation separately we can correctly skip the gaps. We only need to replace the for
loop with the following double loop</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gene_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">cigop</span> <span class="ow">in</span> <span class="n">almnt</span><span class="o">.</span><span class="n">cigar</span><span class="p">:</span>
   <span class="k">if</span> <span class="n">cigop</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;M&quot;</span><span class="p">:</span>
      <span class="k">continue</span>
   <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">features</span><span class="p">[</span> <span class="n">cigop</span><span class="o">.</span><span class="n">ref_iv</span> <span class="p">]</span><span class="o">.</span><span class="n">steps</span><span class="p">():</span>
      <span class="n">gene_ids</span> <span class="o">|=</span> <span class="n">val</span>
</pre></div>
</div>
<p>The outer loop goes through the CIGAR operation, skipping all but the <em>match</em> operations, and
the inner loop inspects the steps covered by the match operations and collects the gene_ids in
the <code class="docutils literal"><span class="pre">gene_ids</span></code> set variable. The rest of the code stays as above.</p>
<p>Of course, custom logic can be implemented her to infer useful information from other cigar
operation types, but for the simple counting task at hand here, we do not need this.</p>
</div>
<div class="section" id="dealing-with-multiple-alignments">
<h3>Dealing with multiple alignments<a class="headerlink" href="#dealing-with-multiple-alignments" title="Permalink to this headline">¶</a></h3>
<p>If the aligner finds multiple alignments for a read, these are typically reported in multiple
SAM records. If the SAM file unsorted or sorted by alignment position, it is hard to look at
all the possible alignments of a given read together, because the records with the alignments
for a given read are spread throughout the file. If the purpose of the counting is subsequent
testing for differential expression, it is often safest, anyway, to skip all multiply
aligned reads (because a read that is counted for several genes may cause spurious calls of
differential expression), and then, we merely need to recognize that a read has multiple
alignments. In the <em>htseq-count</em> script (see ref:<cite>count</cite>), this is done by two means:
First, many (but not all aligners) use the optional field &#8220;NH&#8221;, which indicates the number
of reported alignments. Testing for <code class="docutils literal"><span class="pre">almnt.optional_field(&quot;NH&quot;)</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> allows to find these
read. Also, if there are multiple good alignments, without one of them being considered by the
aligner to be more likely than the others, then the alignment quality (also denoted mapping quality,
MAPQ, in the SAM specification) should be 3 or less. Hence, if one skips all reads with an
alignment quality below, say, 10 (<code class="docutils literal"><span class="pre">almnt.aQual</span> <span class="pre">&lt;</span> <span class="pre">10</span></code>), one will skip over all multiply aligned
reads (provided the aligner indicates the mapping quality correctly, which is not always the case).</p>
<p>For more advanced use cases, it may be desirable to inspect all reported alignment, for example, to
the chose one using some custom logic, or to aggregate information over all of them. If the SAM
or BAM file has been sorted by <em>read name</em> then alternative alignments for the same read will
be in adjacent lines or records. To facilitate handling this case, HTSeq offers the function
function:<cite>bundle_multiple_alignments</cite>. It takes an iterator over <a class="reference internal" href="alignments.html#HTSeq.SAM_Alignment" title="HTSeq.SAM_Alignment"><code class="xref py py-class docutils literal"><span class="pre">SAM_Alignment</span></code></a> objects
(e.g., a <a class="reference internal" href="alignments.html#HTSeq.SAM_Reader" title="HTSeq.SAM_Reader"><code class="xref py py-class docutils literal"><span class="pre">SAM_Reader</span></code></a> or <a class="reference internal" href="alignments.html#HTSeq.BAM_Reader" title="HTSeq.BAM_Reader"><code class="xref py py-class docutils literal"><span class="pre">BAM_Reader</span></code></a> object) and returns an iterator over
lists of <a class="reference internal" href="alignments.html#HTSeq.SAM_Alignment" title="HTSeq.SAM_Alignment"><code class="xref py py-class docutils literal"><span class="pre">SAM_Alignment</span></code></a> objects. Each list contains only records describing alignments
for the same read. For this to work, the SAM file has to be sorted by read name to ensure that
mutiple alignments for the same read appear in adjacent records.</p>
</div>
<div class="section" id="handling-paired-end-reads">
<h3>Handling paired-end reads<a class="headerlink" href="#handling-paired-end-reads" title="Permalink to this headline">¶</a></h3>
<p>In the case of paired-end alignments, we will typically want to count read pairs, not reads. After all,
the fragment (and not the reads from either of its ends) are the actual evidence for a gene&#8217;s expression
that we want to count. Therefore, we want to process the alignment information for the two mated ends
together.</p>
<p>First a quick review of how alignments for paired-end data are presented in a SAM file: The two &#8220;mated&#8221; reads referring to
the two end of a DNA fragment are reported in two separate records. The fact that the records describe
the same fragment can be seen from the fact that they have the same read name (given by the <code class="docutils literal"><span class="pre">read.name</span></code>
slot). That they refer to opposite ends can be seen from the respective bits in the FLAG field, which
are exposed by the <a class="reference internal" href="alignments.html#HTSeq.SAM_Alignment.pe_which" title="HTSeq.SAM_Alignment.pe_which"><code class="xref py py-attr docutils literal"><span class="pre">SAM_Alignment.pe_which</span></code></a> slot of the <a class="reference internal" href="alignments.html#HTSeq.SAM_Alignment" title="HTSeq.SAM_Alignment"><code class="xref py py-class docutils literal"><span class="pre">SAM_Alignment</span></code></a> class, which takes
the values <code class="docutils literal"><span class="pre">first</span></code> or <code class="docutils literal"><span class="pre">second</span></code> (or <code class="docutils literal"><span class="pre">unknown</span></code> if not specified in the flag field, or <code class="docutils literal"><span class="pre">not_paired_end</span></code> if
an alignment of a single-end read is represented) . If the read pair has multiple
alignments, each alignment is reported by a pair of SAM records. As corresponding records are not necessarily
in adjacent lines, they are &#8220;linked&#8221; by the mate position fields (called RNEXT and PNEXT in the SAM specification),
which are exposed by the slot <code class="xref py py-attr docutils literal"><span class="pre">SAM_Alignment.mate_pos</span></code>, which contains a <a class="reference internal" href="genomic.html#HTSeq.GenomicPosition" title="HTSeq.GenomicPosition"><code class="xref py py-class docutils literal"><span class="pre">GenomicPosition</span></code></a>
object. The two records describing the two halves of a given alignment can be recognized as being correspondent
from the fact that each record&#8217;s <code class="docutils literal"><span class="pre">mate_pos</span></code> attribute is equal to the starting position (given by``iv.start_as_pos``).</p>
<p>Note that all the SAM records for a given read pair may be spread throughout the file. Only if the file is sorted
by read name can we expect them to be at adjacent places, and even then, the records for multiple alignments can be
intermixed.</p>
<p>To facilitate handling paired-end alignments, HTSeq offers the function <a class="reference internal" href="alignments.html#HTSeq.pair_SAM_alignments" title="HTSeq.pair_SAM_alignments"><code class="xref py py-func docutils literal"><span class="pre">pair_SAM_alignments()</span></code></a>. This function
expects an iterator over SAM records (typically, a <a class="reference internal" href="alignments.html#HTSeq.SAM_Reader" title="HTSeq.SAM_Reader"><code class="xref py py-class docutils literal"><span class="pre">SAM_Reader</span></code></a> or <a class="reference internal" href="alignments.html#HTSeq.BAM_Reader" title="HTSeq.BAM_Reader"><code class="xref py py-class docutils literal"><span class="pre">BAM_Reader</span></code></a> object) and returns
an iterator over pairs (i.e., tuples of length 2) of <a class="reference internal" href="alignments.html#HTSeq.SAM_Alignment" title="HTSeq.SAM_Alignment"><code class="xref py py-class docutils literal"><span class="pre">SAM_Alignment</span></code></a> records, with the first element being the alignment of the
read from the first sequencing pass (i.e., from the 5&#8217; end of the DNA fragment) and the second element the corresponding alignment
from the second pass (i.e., the 3&#8217; read). The function expects the SAM file to be sorted by read name. It proceeds by reading
in consecutive records with the same read name and storing them in a list. Once it finds a record with a differing read name,
the function goes through the list, sorts its content into pairs of corresponding alignment records and yields these pairs. If the
function&#8217;s option <code class="docutils literal"><span class="pre">bundle``[TODO:</span> <span class="pre">add</span> <span class="pre">description</span> <span class="pre">of</span> <span class="pre">&quot;bundle&quot;</span> <span class="pre">in</span> <span class="pre">alignment.rst,</span> <span class="pre">too]</span> <span class="pre">is</span>
<span class="pre">set</span> <span class="pre">to</span> <span class="pre">``True</span></code>, the function does not yield the pairs separately but instead yields a list of all alignment pairs for
the same read.</p>
<p>Using these features, we can modify our counting loop as follows for paired-end data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">almnt_file</span> <span class="o">=</span> <span class="n">HTSeq</span><span class="o">.</span><span class="n">SAM_Reader</span><span class="p">(</span> <span class="s2">&quot;my_paired_alignments.sam&quot;</span> <span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span> <span class="p">)</span>
<span class="k">for</span> <span class="n">bundle</span> <span class="ow">in</span> <span class="n">HTSeq</span><span class="o">.</span><span class="n">pair_SAM_alignments</span><span class="p">(</span> <span class="n">almnt_file</span><span class="p">,</span> <span class="n">bundle</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
      <span class="k">continue</span>  <span class="c1"># Skip multiple alignments</span>
   <span class="n">first_almnt</span><span class="p">,</span> <span class="n">second_almnt</span> <span class="o">=</span> <span class="n">bundle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># extract pair</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">first_almnt</span><span class="o">.</span><span class="n">aligned</span> <span class="ow">and</span> <span class="n">second_almnt</span><span class="o">.</span><span class="n">aligned</span><span class="p">:</span>
      <span class="n">count</span><span class="p">[</span> <span class="s2">&quot;_unmapped&quot;</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">continue</span>
   <span class="n">gene_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
   <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">features</span><span class="p">[</span> <span class="n">left_almnt</span><span class="o">.</span><span class="n">iv</span> <span class="p">]</span><span class="o">.</span><span class="n">steps</span><span class="p">():</span>
      <span class="n">gene_ids</span> <span class="o">|=</span> <span class="n">val</span>
   <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">features</span><span class="p">[</span> <span class="n">right_almnt</span><span class="o">.</span><span class="n">iv</span> <span class="p">]</span><span class="o">.</span><span class="n">steps</span><span class="p">():</span>
      <span class="n">gene_ids</span> <span class="o">|=</span> <span class="n">val</span>
   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">gene_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">counts</span><span class="p">[</span> <span class="n">gene_id</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
   <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">counts</span><span class="p">[</span> <span class="s2">&quot;_no_feature&quot;</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">counts</span><span class="p">[</span> <span class="s2">&quot;_ambiguous&quot;</span> <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">gene_id</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
   <span class="nb">print</span> <span class="n">gene_id</span><span class="p">,</span> <span class="n">counts</span><span class="p">[</span> <span class="n">gene_id</span> <span class="p">]</span>
</pre></div>
</div>
<p>Note that here, we skip reads if only one of two mates are aligned. Of course, one could choose as well to count such a
pair for the gene to which the aligned mate has been mapped.</p>
<p>The need to sort paired-end SAM files by read name can be an inconvenience, because many aligners output the SAM file
sorted by position. In many use case, we can expect that the two ends of the same read will align to positions close
to each other on the genome. Then, an alternative strategy to pair up alignment records is go through the SAM file,
which has been sorted by position, and keep a dictionary of alignment records whose partner record has not been found yet.
For each record, we check the dictionary for its partner (i.e., for a record with the same read name and matching
position information). If we find the partner, we remove it from the dictionary and yield both together as a pair. If the partner
is not in the dictionary, the record is stored in the dictionary to wait for its partner to come along. As long as
mated records are not too far from each other in the file, the dictionary will only contain a manageable number of records.
Only if reads are often very far from each other (e.g., because the file was not sorted by position), the dictionary
might become too large to fit into memory. HTSeq offers this manner of pairing up alignment records in the function
<code class="xref py py-func docutils literal"><span class="pre">pair_SAM_alignment_with_buffer()</span></code>, which can be used in the same manner as <code class="xref py py-func docutils literal"><span class="pre">pair_SAM_alignment()</span></code>, but
takes one optional additional argument, the maximum size of the buffer (by default, 3 million).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Counting reads</a><ul>
<li><a class="reference internal" href="#preparing-the-feature-array">Preparing the feature array</a></li>
<li><a class="reference internal" href="#counting-ungapped-single-end-reads">Counting ungapped single-end reads</a></li>
<li><a class="reference internal" href="#counting-gapped-single-end-reads">Counting gapped single-end reads</a><ul>
<li><a class="reference internal" href="#cigar-operations">CIGAR Operations</a></li>
<li><a class="reference internal" href="#counting-with-gapped-reads">Counting with gapped reads</a></li>
<li><a class="reference internal" href="#dealing-with-multiple-alignments">Dealing with multiple alignments</a></li>
<li><a class="reference internal" href="#handling-paired-end-reads">Handling paired-end reads</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tss.html"
                        title="previous chapter">A detailed use case: TSS plots</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="refoverview.html"
                        title="next chapter">Reference overview</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/counting.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="refoverview.html" title="Reference overview"
             >next</a> |</li>
        <li class="right" >
          <a href="tss.html" title="A detailed use case: TSS plots"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">HTSeq 0.7.2 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010, Simon Anders.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
  </body>

<!-- Start of StatCounter Code -->
<script type="text/javascript">
var sc_project=5680199; 
var sc_invisible=1; 
var sc_partition=63; 
var sc_click_stat=1; 
var sc_security="6e579550"; 
</script>

<script type="text/javascript"
src="http://www.statcounter.com/counter/counter.js"></script><noscript><div
class="statcounter"><a title="counter for iweb"
href="http://www.statcounter.com/iweb/" target="_blank"><img
class="statcounter"
src="http://c.statcounter.com/5680199/0/6e579550/1/"
alt="counter for iweb" ></a></div></noscript>
<!-- End of StatCounter Code -->
</html>